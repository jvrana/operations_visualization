{"name":"Golden Gate Assembly","category":"Cloning","deployed":false,"on_the_fly":false,"field_types":[{"role":"input","name":"Inserts","sample_types":["Plasmid","Fragment"],"object_types":["Plasmid Stock","Fragment Stock"],"part":false,"array":true},{"role":"output","name":"Plasmid","sample_types":["Plasmid"],"object_types":["Golden Gate Stripwell"],"part":true,"array":false},{"role":"input","name":"Backbone","sample_types":["Plasmid","Fragment"],"object_types":["Plasmid Stock","Fragment Stock"],"part":false,"array":false},{"role":"input","name":"Enzyme","sample_types":["Enzyme"],"object_types":["Enzyme Stock"],"part":false,"array":false}],"protocol":"# This is a default, one-size-fits all protocol that shows how you can \n# access the inputs and outputs of the operations associated with a job.\n# Add specific instructions for this protocol!\n# http://barricklab.org/twiki/bin/view/Lab/ProtocolsGoldenGateAssembly\n\nclass Protocol\n  \n  LIGASE = \"T4 DNA Ligase\"\n  LIGASE_BUFFER = \"T4 DNA Ligase Buffer\"\n  INSERT = \"Inserts\"\n  BACKBONE = \"Backbone\"\n  RSII = \"Enzyme\"\n  DEFAULT_LENGTH = 5000.0\n  REACTION_VOLUME = 20.0\n  BACKBONE_fM = 40.0\n  INSERT_fM = 40.0\n  \n  def main\n\n    if debug\n        operations.each { |op| op.set_input_data INSERT, :concentration,  rand(600) }\n        operations.each { |op| op.set_input_data BACKBONE, :concentration,  rand(600) }\n    end\n\n\n  # Gather items from inputs\n    inserts = operations.collect { |op| op.input_array(INSERT).items }[0]\n    backbones = operations.collect { |op| op.input(BACKBONE).item }\n    rsii = operations.collect { |op| op.input(RSII).item }\n    \n  # Gather hard-coded items\n    ligase = find(:item, { sample: { name: LIGASE }, object_type: { name: \"Enzyme Stock\" } } ).first\n    ligase_buffer = find(:item, { sample: { name: LIGASE_BUFFER }, object_type: { name: \"Enzyme Buffer Stock\" } } ).first\n\n# TODO: Change DNA inputs to be 40fmol/ul stock, make new operation for creating stock\n\n# STEP: Take items\n    dnas = inserts + backbones\n    take dnas, interactive: true, method: \"boxes\"\n    take [ligase_buffer], interactive: true, method: \"boxes\"\n    \n    enzymes = rsii + [ligase]\n    take enzymes, interactive: true, method: \"boxes\"\n\n\n\n\n\n# TODO: Only ask if enzyme has no concentration\n# STEP: Ask about concentrations of enzymes\n    # user_input = show do\n    #     title \"Update concentrations for enzymes\"\n    #     enzymes.each do |e|\n    #         get \"number\", var: \"Concentration of item #{e.id}\".to_sym, label: \"Enter concentration (U/uL):\", default: 10\n    #     end\n        \n    #     note \"Look at the side of the tube for concentration. Units should be expressed in U/uL. If expressed in U/mL, divide by 1000.\"\n    # end\n    \n    # enzymes.each do |e|\n    #     e.associate :concentration, user_input[\"Concentration of item #{e.id}\"]\n    # end\n\n# TODO: Raise error if the lengths are set set\n# STEP: Assess volumes for reactions\n    def calc_conc_fM(input)\n        conc = input.item.get(:concentration) || 300\n        conc = rand(600) if debug\n        length = input.sample.properties[\"Length\"]\n        length = DEFAULT_LENGTH if length == 0\n        conc_fM = conc / (6.5 * 10**-4 * length)\n        return conc_fM\n    end\n    \n    operations.each do |op|\n        \n        # Calculate concentrations\n        insert_conc_fM = op.input_array(INSERT).map { |i| calc_conc_fM(i) }\n        backbone_conc_fM = calc_conc_fM(op.input(BACKBONE)).round(2)\n        \n        # Calculate volumes\n        insert_vol = insert_conc_fM.map { |fm| (INSERT_fM / fm).round(2) }\n        backbone_vol = (BACKBONE_fM / backbone_conc_fM).round(2)\n        ligase_buffer_vol = (REACTION_VOLUME / 10.0).round(1)\n        enzyme_vol = 1.0\n        ligase_vol = 1.0\n        \n        # Store volumes\n        op.temporary[:insert_conc_fM] = insert_conc_fM\n        op.temporary[:backbone_conc_fM] = backbone_conc_fM\n        op.temporary[:insert_vol] = insert_vol\n        op.temporary[:backbone_vol] = backbone_vol\n        op.temporary[:ligase_buffer_vol] = ligase_buffer_vol\n        op.temporary[:enzyme_vol] = enzyme_vol\n        op.temporary[:ligase_vol] = ligase_vol\n        total_insert_vol = insert_vol.inject(0){|sum,x| sum + x }\n        op.temporary[:water_vol] = REACTION_VOLUME - total_insert_vol - backbone_vol - ligase_buffer_vol - enzyme_vol - ligase_vol\n    \n    end\n\n# TODO: group operations by item id used\n    def group_op_by_item_id(input_name)\n        grouped_values = operations.group_by { |op| op.input(input_name).item.id }.values\n        keys = grouped_values.map { |g| g[0].input(input_name).item.id }\n        Hash[keys.zip(grouped_values)]\n    end\n\n    enzyme_to_op_hash = group_op_by_item_id(RSII)\n    # insert_to_op_hash = group_op_by_item_id(INSERT)\n    # backbone_to_op_hash = group_op_by_item_id(BACKBONE)\n    # ligase_to_op_hash = group_op_by_item_id(LIGASE)\n    # ligase_buffer_to_op_hash = group_op_by_item_id(LIGASE_BUFFER)\n    \n    if debug\n        show do\n            title \"Calculation table\"\n            \n            table operations.start_table\n                .input_item(INSERT)\n                .custom_column(heading: \"Concentration (ng/uL)\") { |op| op.input(INSERT).item.get(:concentration) }\n                .custom_column(heading: \"fM\") { |op| op.temporary[:insert_conc_fM] }\n                .custom_column(heading: \"Length (bp)\") { |op| op.input(INSERT).sample.properties[\"Length\"] }\n                .end_table\n                \n            table operations.start_table\n                .input_item(BACKBONE)\n                .custom_column(heading: \"Concentration (ng/uL)\") { |op| op.input(BACKBONE).item.get(:concentration) }\n                .custom_column(heading: \"fM\") { |op| op.temporary[:backbone_conc_fM] }\n                .custom_column(heading: \"Length (bp)\") { |op| op.input(BACKBONE).sample.properties[\"Length\"] }\n                .end_table\n        end\n    end\n    \n    # show do\n    #     title \"Input Array Bug\"\n        \n    #     operations.each do |op|\n    #         note \"#{op.input_array(INSERT).items}\"\n    #     end\n    # end\n    \n    \n    \n    \n    \n    \n    \n# STEP: Volume checks\n    volume_checks = show do\n        \n        \n        \n        # TODO: Volume check ligase\n        # total_ligase_vol = operations.inject(0) { |sum, op| sum + op.temporary[:ligase_vol] }\n        # get \"string\", var: \"enough_ligase\".to_sym, label: \"enough?\", default: 'y'\n        # TODO: Volume check each enzyme\n        \n        # Volume check for each input and backbone\n        title \"Ensure plasmid/fragment stocks contain enough volume for the reaction.\"\n        \n        # TODO: group insert and backbones (in case they are the same)\n        table operations.start_table\n            .input_item(INSERT)\n            .custom_column(heading: \"Total required volume (uL)\") { |op| op.temporary[:insert_vol] }\n            .get(:enough_insert_volume, type: \"string\", default: 'y', heading: \"Enough volume (y/n)?\")\n            .end_table\n        \n        \n        table operations.start_table\n            .input_item(BACKBONE)\n            .custom_column(heading: \"Required volume (uL)\") { |op| op.temporary[:insert_vol] }\n            .get(:enough_backbone_volume, type: \"string\", default: 'y', heading: \"Enough volume (y/n)?\")\n            .end_table\n    end\n    \n    operations.each do |op|\n        if debug\n            op.temporary[:enough_insert_volume] = ['y', 'y', 'n'].sample\n        end\n        \n        if op.temporary[:enough_insert_volume].downcase == \"n\"\n            op.set_status \"error\"\n            op.associate :not_enough_insert_volume, \"Your insert stock for #{op.input(INSERT).sample.name} \" + \n                \"(Sample: #{op.input(INSERT).sample} Item: #{op.input(INSERT).item}) did not have enough volume.\"\n        end\n        \n        if op.temporary[:enough_backbone_volume].downcase == \"n\"\n            op.set_status \"error\"\n            op.associate :not_enough_backbone_volume, \"Your insert stock for #{op.input(BACKBONE).sample.name} \" + \n                \"(Sample: #{op.input(BACKBONE).sample} Item: #{op.input(BACKBONE).item}) did not have enough volume.\"\n        end\n    end\n    \n    # operations.running.retrieve.make\n    show do\n        note \"#{ligase.id}\"\n    end\n\n# STEP: Prepare master mix\n    enzyme_ids = rsii.map { |e| e.id }\n    show do\n        master_mix_total_volume = 10\n        master_mixes = []\n# TODO: If theres only one or two types of enzymes make one or two master mixes\n# TODO: Else, make a ligase, buffer, water only master mix\n        i = 0\n        enzyme_to_op_hash.each do |k, v|\n            ligase_vol = v.inject(0) { |sum, op| sum + op.temporary[:ligase_vol] }\n            ligase_buffer_vol = v.inject(0) { |sum, op| sum + op.temporary[:ligase_buffer_vol] }\n            enzyme_vol = v.inject(0) { |sum, op| sum + op.temporary[:enzyme_vol] }\n            water_vol = master_mix_total_volume - ligase_vol - ligase_buffer_vol - enzyme_vol\n            enzyme_array = enzyme_ids.map { |e| e == k ? enzyme_vol : 0 }\n            volumes = [water_vol, ligase_buffer_vol, ligase_vol] + enzyme_array\n            note \"#{volumes}\"\n            i += 1\n        end\n    end\n    \n    m = [\n  [ \"A\", \"Very\", \"Nice\", { content: \"Table\", style: { color: \"#f00\" } } ],\n  [ { content: 1, check: true }, 2, 3, 4 ]\n]\n\nshow {\n  title \"A Table\"\n  table m\n}\n    \n\n# STEP: Prepare stripwell\n\n    # volume check\n    # show do\n    #   title \"Ensure plasmid stocks contain enough volume for the reaction\"\n      \n    #   table operations.start_table\n    #     .input_item(\"Plasmid\")\n    #     .custom_column(heading: \"Required volume (ÂµL)\") { |op| op.temporary[:stock_vol] }\n    #     .get(:enough_volume, type: \"string\", default: 'y', heading: \"Enough volume (y/n)?\")\n    #     .end_table\n    # end\n    \n    # operations.each do |op|\n    #   if op.temporary[:enough_stock_volume].downcase == \"n\"\n    #     op.set_status \"error\"\n    #     op.associate :not_enough_volume, \"Your plasmid stock did not have enough volume. Please make another!\"\n    #   end\n    # end\n        \n        \n        #grouped = ops.map { |op| op.inpus(RSII).sample.name } #ops.group_by { |op| op.input(RSII).sample.name }\n        # grouped.each do |g|\n        #     note \"#{g}\"\n        # end\n        \n        # total_ligase_vol = operations.inject(0) { |sum, op| sum + op.temporary[:ligase_vol] }\n        # total_enzyme_vol = operations.inject(0) { |sum, op| sum + op.temporary[:ligase_vol] }\n        \n    \n    \n    # show do \n    #         table operations.start_table\n    #         .result(:insert_vol, heading: \"Insert Volume\")\n    #         .end_table\n    # end\n    \n# STEP: Volume check for inserts and fragments\n# STEP: Volume check for ligase buffer\n# STEP: Volume check for ligase\n# STEP: Volume check for RSII\n\n# STEP: Prepare master mix (RSII + ligase), grouped by RSII\n\n# STEP: Prepare fragments\n\n# STEP: Add Master Mix\n\n# STEP: PCR machine\n\n# STEP: Set timer to fire other protocol\n    \n    # tin  = operations.io_table \"input\"\n    # tout = operations.io_table \"output\"\n    \n    # show do \n    #   title \"Input Table\"\n    #   table tin.all.render\n    # end\n    \n    # show do \n    #   title \"Output Table\"\n    #   table tout.all.render\n    # end\n    \n\n    \n    # operations.store(io: \"input\")\n    #           .store(io: \"output\") \n    \n    return {}\n    \n  end\n\nend\n    \n    # collect backbone\n    # collect inserts\n    # Collect T4 ligase buffer to thaw (T4 ligase aliquot?)\n    \n    # Gather a cooler\n    # Collect restriction enzyme and place in cooler\n    # Collect T4 ligase and place in cooler\n\n    # TODO: verify sufficient volume of enzyme, T4, and buffer\n    # TODO: verify volumes of inputs\n    \n    # mix reagents\n    \n    # update all volumes\n","cost_model":"def cost(op)\n  { labor: 0, materials: 0 }\nend","documentation":"New Operation Type\n===\n\nDocumentation here"}